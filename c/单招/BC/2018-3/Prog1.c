/*-------------------------------------------------------------------------
【程序设计】
---------------------------------------------------------------------------
题目：字符串s[]="&& 3yh-14 AS-21HJ*@#35 +ei-84pTR42 -56",程序将连续的负整数
      字符转换为正整数，并计算这些正整数的最大公约数。

编写程序：
1.函数int f(char s[],int a[])将字符串s中连续的负整数字符转换为正整数存储在
  数组a中，函数返回a中元素个数。

2.函数int gcds(int a[], int n)计算a中n个元素的最大公约数，并返回该公约数。

测试数据
        "&& 3yh-14 AS-21HJ*@#35 +ei-84pTR42 -56"

运行f函数后的结果是：         14 21 84 56
运行gcds函数后的结果是：  最大公约数为：7

---------------------------------------------------------
注意：请勿改动主函数main()中的任何语句。
-------------------------------------------------------*/
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
int f(char s[],int a[])
{
/**********Program**********/
       



/**********  End  **********/

}
int gcds(int a[], int n)
{
/**********Program**********/

   


/**********  End  **********/

}

int main()
{
    char s[]={"&& 3yh-14 AS-21HJ*@#35 +ei-84pTR42 -56"};
    int i,n,a[10];
    FILE *fp;
    if((fp=fopen("DATA.dat","w"))==NULL)
    {
        printf("File insen error\n");
        exit(0);
    }
    n=f(s,a);
    for(i=0;i<n;i++)
    {
        printf("%d\t",a[i]);
        fprintf(fp,"%4d",a[i]);
    }
    printf("\n最大公约数为：%d\n",gcds(a,n));
    fprintf(fp,"\n%d\n",gcds(a,n));
    fclose(fp);
    return 0;
}
